# Вопросы

## Темы для подготовки к защите лабораторной работы (se.ifmo):
- Структура процесса и потоков;
- Системные утилиты сбора статистики ядра;
- Основы ввода-вывода (блочный и последовательный ввод-вывод);
- Файловая система procfs;
- Использование утилиты strace, ltrace, bpftrace;
- Профилирование и построение flamegraph'а и stap;

## Ещё вопросы:

- Что такое процесс, поток, корутина?
- Какие существуют способы создания процессов и потоков?
- Разница между fork, vfork, clone, и т.д.?
- Вытесняющая и кооперативная многозадачность?
- Состояния процесса?
- Какие существуют способы синхронизации потоков? (Примитивы синхронизации)
- User level threads и kernel level threads?
- Paging, swapping?
# Ответы

## Структура процесса и потоков
- Процесс — это независимая единица выполнения программы, имеющая собственное адресное пространство, ресурсы и состояние выполнения. Процессы обеспечивают изоляцию программ друг от друга, позволяя им выполняться независимо.
    - Процессы (fork/clone3): Независимые единицы выполнения с собственным адресным пространством. Используются для изолированного выполнения программ. Системные вызовы fork и clone3 позволяют создавать новые процессы. fork создает точную копию текущего процесса, а clone3 предоставляет более гибкие возможности, позволяя настроить, какие ресурсы будут общими между родительским и дочерним процессами.
- Поток (или нить) — это легковесная единица выполнения внутри процесса. Потоки разделяют адресное пространство процесса и могут выполняться параллельно, что повышает производительность приложения.
    - Потоки (std::thread): Легковесные единицы выполнения внутри одного процесса, разделяющие адресное пространство. В языке C++ класс std::thread используется для создания и управления потоками, позволяя реализовать многопоточность в приложении.

## Системные утилиты сбора статистики ядра
Системные утилиты предоставляют информацию о работе ядра и системы в целом:
- top: Отображает информацию о процессах и их использовании ресурсов в реальном времени.
- vmstat: Показывает статистику использования памяти, CPU и ввода-вывода.
- iostat: Предоставляет данные о загрузке дисковой системы.
- mpstat: Отображает статистику по каждому CPU.
Top: (https://superuser.com/questions/575202/understanding-top-command-in-unix/575330#575330)

## Основы ввода-вывода (блочный и последовательный ввод-вывод)
- Блочный ввод-вывод: Операции выполняются с фиксированными блоками данных. Используется для работы с устройствами хранения данных, такими как жесткие диски и SSD.
- Последовательный ввод-вывод: Данные читаются или записываются последовательно, байт за байтом. Применяется для устройств, где важен порядок данных, например, для терминалов и сетевых соединений.

## Файловая система procfs
procfs — виртуальная файловая система, предоставляющая информацию о процессах и состоянии системы. Она монтируется в каталог /proc и позволяет получать данные о запущенных процессах, конфигурации ядра и системных ресурсах. Например, файл /proc/cpuinfo содержит информацию о процессоре, а /proc/meminfo — о памяти.

## Использование утилиты strace, ltrace, bpftrace
- strace: Инструмент для отслеживания системных вызовов и сигналов, используемых процессом. Полезен для отладки и анализа поведения программ.
- ltrace: Позволяет отслеживать вызовы библиотечных функций, что помогает понять взаимодействие программы с динамическими библиотеками.
- bpftrace: Современный инструмент для динамического трассирования на основе технологии eBPF. Позволяет создавать сложные сценарии мониторинга и отладки системы без изменения исходного кода.
  - eBPF: (extended Berkeley Packet Filter) — это технология, позволяющая выполнять безопасные программы внутри ядра Linux без необходимости изменения исходного кода или загрузки модулей ядра. Изначально разработанный для фильтрации сетевых пакетов, eBPF эволюционировал в универсальный инструмент для мониторинга, отладки и повышения производительности системы.

## Профилирование и построение flamegraph'а и stap
- Профилирование: Процесс анализа программы для определения ее производительности, выявления узких мест и оптимизации использования ресурсов.
- Flamegraph: Графическое представление стека вызовов, показывающее, сколько времени тратится на каждую функцию. Помогает визуально идентифицировать узкие места в производительности.
- SystemTap (stap): Инструмент для динамического отслеживания работы ядра и приложений. Позволяет писать скрипты для сбора данных о работе системы без необходимости перезагрузки или модификации ядра.

## Что такое процесс, поток, корутина?
- Процесс: Независимая программа в состоянии выполнения с собственным адресным пространством и ресурсами.
- Поток: Наименьшая единица обработки, выполняемая планировщиком. Потоки внутри одного процесса разделяют его ресурсы и могут выполняться параллельно.
- Корутина: Компонент программирования, позволяющий приостанавливать и возобновлять выполнение функции. Обеспечивает кооперативную многозадачность внутри одного потока или процесса.

## Какие существуют способы создания процессов и потоков?
Создание процессов:

- fork(): Создает новый процесс путем копирования текущего.
- vfork(): Похожа на fork(), но оптимизирована для случаев, когда дочерний процесс сразу вызывает exec() или exit().
- clone(): Более гибкий системный вызов для создания процессов или потоков с определенными общими ресурсами.
- clone3(): Расширенная версия clone() с дополнительными возможностями настройки создания процессов.

Создание потоков:

- POSIX Threads (pthread): Библиотека для работы с потоками в C/C++.
- std::thread: Класс из стандартной библиотеки C++11 и выше для управления потоками.
- Библиотеки языков высокого уровня: В языках Python, Java и других существуют собственные средства для работы с потоками.

## Разница между fork, vfork, clone, и т.д.?
- fork(): Создает новый процесс, копируя адресное пространство родительского процесса. Дочерний процесс получает копию всех ресурсов.
- vfork(): Создает новый процесс, но не копирует адресное пространство. Дочерний процесс выполняется в адресном пространстве родителя до вызова exec() или exit(). Это экономит ресурсы, но требует осторожности.
- clone(): Позволяет более гибко настроить создание процессов или потоков, указывая, какие ресурсы будут общими (например, память, файловые дескрипторы, таблица сигналов).

## Вытесняющая и кооперативная многозадачность?
- Вытесняющая многозадачность: Планировщик операционной системы самостоятельно распределяет время выполнения между задачами. Задачи могут быть прерваны в любой момент для выполнения другой задачи.
- Кооперативная многозадачность: Задачи сами решают, когда уступить управление. Если задача не уступает управление, другие задачи не могут выполняться, что может привести к проблемам.

## Состояния процесса?
- New: Процесс создан, но еще не выполняется.
- Ready/Runnable: Процесс готов к выполнению и ожидает выделения процессорного времени.
- Running: Процесс выполняется на процессоре.
- Waiting/Blocked: Процесс ожидает завершения операции ввода-вывода или другого события.
- Terminated: Процесс завершен и освобождает ресурсы.

## Какие существуют способы синхронизации потоков? (Примитивы синхронизации)
- Mutex (мьютекс): Обеспечивает эксклюзивный доступ к общему ресурсу. Поток, захвативший мьютекс, может выполнять операции, остальные потоки ждут его освобождения.
- Semaphore (семафор): Позволяет ограничить количество потоков, имеющих доступ к ресурсу. Семафор может быть счетчиком доступных ресурсов.
- Condition Variable (условная переменная): Позволяет потокам ожидать определенного условия перед продолжением выполнения.
- Read-Write Lock (блокировка чтения-записи): Позволяет множеству потоков читать данные одновременно, но только одному потоку писать.
- Barrier (барьер): Синхронизирует выполнение нескольких потоков, ожидая, пока все они достигнут определенной точки.
- Spinlock это механизм синхронизации, используемый в многопоточных системах для обеспечения эксклюзивного доступа к общим ресурсам. В отличие от мьютексов, при ожидании освобождения spinlock поток активно проверяет состояние блокировки в цикле ("крутится"), что может быть эффективным при коротких периодах ожидания.

## User level threads и kernel level threads?
- Потоки уровня пользователя (User-Level Threads): Управляются библиотеками в пространстве пользователя, не требуют переключения контекста ядра, но не могут использовать преимущества многопроцессорных систем.
- Потоки уровня ядра (Kernel-Level Threads): Управляются ядром операционной системы, могут выполняться параллельно на нескольких процессорах, но имеют большие накладные расходы на управление.

## Paging, swapping?
- Paging (Страничная организация памяти): Метод управления памятью, при котором виртуальное адресное пространство разделяется на страницы фиксированного размера. Это позволяет эффективно использовать память и обеспечивает защиту памяти между процессами.
- Swapping (Вытеснение): Процесс перемещения страниц памяти на диск (в область подкачки) для освобождения оперативной памяти. Когда данные снова требуются, они загружаются обратно в оперативную память. Swapping позволяет системе работать с объемом данных, превышающим доступную оперативную память, но может снижать производительность из-за времени доступа к диску.

## KThread
(Kernel Thread) — это поток, выполняющийся в пространстве ядра операционной системы. В отличие от пользовательских потоков, kthreads работают исключительно в контексте ядра и используются для выполнения задач, требующих привилегированного доступа, таких как управление аппаратными устройствами, обработка прерываний и выполнение фоновых системных задач. Kthreads создаются и управляются самим ядром и не имеют прямого взаимодействия с пользовательским пространством.
